/*
 * Treezor API
 * As a REST API, Treezor accepts and returns JSON payloads, along with the associated `application/json` content type.  You can learn everything you need to know about authentication, credentials, data formats, and more in the [API Basics](/guide/api-basics/environments.html) section.  Like the rest of the documentation, this reference focuses on the latest version of the Treezor API (Connect). 
 *
 * The version of the OpenAPI document: 25.04.03
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.sdk.treezor.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.math.BigDecimal;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * PutBeneficiaryRequestSddB2bWhitelistInner
 */
@JsonPropertyOrder({
  PutBeneficiaryRequestSddB2bWhitelistInner.JSON_PROPERTY_UNIQUE_MANDATE_REFERENCE,
  PutBeneficiaryRequestSddB2bWhitelistInner.JSON_PROPERTY_IS_RECURRENT,
  PutBeneficiaryRequestSddB2bWhitelistInner.JSON_PROPERTY_WALLET_ID
})
@JsonTypeName("putBeneficiary_request_sddB2bWhitelist_inner")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-14T09:49:28.273669400+02:00[Europe/Paris]", comments = "Generator version: 7.12.0")
public class PutBeneficiaryRequestSddB2bWhitelistInner {
  public static final String JSON_PROPERTY_UNIQUE_MANDATE_REFERENCE = "uniqueMandateReference";
  @javax.annotation.Nonnull
  private String uniqueMandateReference;

  public static final String JSON_PROPERTY_IS_RECURRENT = "isRecurrent";
  @javax.annotation.Nonnull
  private Boolean isRecurrent;

  public static final String JSON_PROPERTY_WALLET_ID = "walletId";
  @javax.annotation.Nullable
  private BigDecimal walletId;

  public PutBeneficiaryRequestSddB2bWhitelistInner() {
  }

  public PutBeneficiaryRequestSddB2bWhitelistInner uniqueMandateReference(@javax.annotation.Nonnull String uniqueMandateReference) {
    
    this.uniqueMandateReference = uniqueMandateReference;
    return this;
  }

  /**
   * The unique reference that unambiguiously identify a mandate signed between the user and the beneficiary.   See the [Unique Mandate Reference (UMR)](/guide/overview/glossary.html#unique-mandate-reference-umr) article for more information. 
   * @return uniqueMandateReference
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_UNIQUE_MANDATE_REFERENCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getUniqueMandateReference() {
    return uniqueMandateReference;
  }


  @JsonProperty(JSON_PROPERTY_UNIQUE_MANDATE_REFERENCE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setUniqueMandateReference(@javax.annotation.Nonnull String uniqueMandateReference) {
    this.uniqueMandateReference = uniqueMandateReference;
  }

  public PutBeneficiaryRequestSddB2bWhitelistInner isRecurrent(@javax.annotation.Nonnull Boolean isRecurrent) {
    
    this.isRecurrent = isRecurrent;
    return this;
  }

  /**
   * If mandate is a recuring payment, this field must be true. 
   * @return isRecurrent
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_IS_RECURRENT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getIsRecurrent() {
    return isRecurrent;
  }


  @JsonProperty(JSON_PROPERTY_IS_RECURRENT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setIsRecurrent(@javax.annotation.Nonnull Boolean isRecurrent) {
    this.isRecurrent = isRecurrent;
  }

  public PutBeneficiaryRequestSddB2bWhitelistInner walletId(@javax.annotation.Nullable BigDecimal walletId) {
    
    this.walletId = walletId;
    return this;
  }

  /**
   * If present, the Direct Debit will be accepted only if the targeted wallet is the wallet with the given walletId. Without this value, the SDD can target any wallets of the user. With the value specified, only the explicitely authorized wallet can be targeted by SDD. 
   * @return walletId
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_WALLET_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public BigDecimal getWalletId() {
    return walletId;
  }


  @JsonProperty(JSON_PROPERTY_WALLET_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setWalletId(@javax.annotation.Nullable BigDecimal walletId) {
    this.walletId = walletId;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PutBeneficiaryRequestSddB2bWhitelistInner putBeneficiaryRequestSddB2bWhitelistInner = (PutBeneficiaryRequestSddB2bWhitelistInner) o;
    return Objects.equals(this.uniqueMandateReference, putBeneficiaryRequestSddB2bWhitelistInner.uniqueMandateReference) &&
        Objects.equals(this.isRecurrent, putBeneficiaryRequestSddB2bWhitelistInner.isRecurrent) &&
        Objects.equals(this.walletId, putBeneficiaryRequestSddB2bWhitelistInner.walletId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uniqueMandateReference, isRecurrent, walletId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PutBeneficiaryRequestSddB2bWhitelistInner {\n");
    sb.append("    uniqueMandateReference: ").append(toIndentedString(uniqueMandateReference)).append("\n");
    sb.append("    isRecurrent: ").append(toIndentedString(isRecurrent)).append("\n");
    sb.append("    walletId: ").append(toIndentedString(walletId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

